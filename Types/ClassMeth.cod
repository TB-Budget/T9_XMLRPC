--XMLRPC - удаленный вызов процедур (c) Златовратский Павел(ТБ.Бюджет), 2014

--Данный проект является свободным программным обеспечением. Вы вправе распространять его
--и/или модифицировать в соответствии с условиями версии 2.1 либо по вашему выбору с условиями
--более поздней версии Стандартной Общественной Лицензии Ограниченного Применения GNU,
--опубликованной Free Software Foundation.

--Мы распространяем этот проект в надежде на то, что он будет вам полезен, однако
--НЕ ПРЕДОСТАВЛЯЕМ НА НЕГО НИКАКИХ ГАРАНТИЙ, в том числе ГАРАНТИИ ТОВАРНОГО СОСТОЯНИЯ ПРИ ПРОДАЖЕ
--и ПРИГОДНОСТИ ДЛЯ ИСПОЛЬЗОВАНИЯ В КОНКРЕТНЫХ ЦЕЛЯХ. Для получения более подробной информации
--ознакомьтесь со Стандартной Общественной Лицензией Ограниченного Применений GNU.

--Вместе с данным проектом вы должны были получить экземпляр Стандартной Общественной Лицензии
--Ограниченного Применения GNU. Если вы его не получили, сообщите об этом в Software Foundation, Inc.,
--59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

class  'Метод класса как экземпляр функции';
  Import СИС2 Classes оперСистемные;

InClass Public
  func CreateEx(aMethodName :String):ClassMeth;
    Result = Create;
    Result.FromString(aMethodname);
  end;

InObject Private
  myClass:Class;
  myMeth:MethodInfo;

InObject Public
  proc Загрузить synonym Load(aClass:Class;aMeth:MethodInfo);
    myClass=aClass;
    myMeth=aMeth;
  end;

  proc ИзСтроки synonym FromString(aMethodName :String);
  var i:Integer;
  var sCl,sMe:String;
    i = WordsCount(aMethodName, '.');
    sMe = ExtractWord(aMethodName, i, '.');
    sCl = SubStr(aMethodName, 1, Length(aMethodName) - Length(sMe) - 1);
    if sCl = '' then 
      SetError(0,"Метод не найден, проверьте задание имени класса");
    end;
    myClass  = FindClass(sCl);
    if myClass = nil then
       SetError(0,"Класс "+sCl+" не найден");
    end;
    myMeth = ПолучитьИнфоМетода(myClass, sMe);
  end;

  func Вызвать synonym Call(Params:Variant[]):Variant;
    if myMeth.Kind=2 then--MethodInfo.MethodKind("mkFunc") then
       Result=myMeth.CallFuncEx(myClass,Params);
    elsif myMeth.Kind=1 then--MethodInfo.MethodKind("mkProc") then
       try
         myMeth.CallProcEx(myClass,Params);
         Result=True;
       except
         Result=False;
         raise;
       end;
    else
      SetError(0,"Метод не является процедурой или функцией");
      Result=False;
    end;
  end;
end